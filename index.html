<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]>      <html class="no-js"> <!--<![endif]-->
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title>Pressure</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <!-- Favicon -->
        <link rel="icon" type="image/png" sizes="32x32" href="/img/favicon.png">
        <!-- Bootstrap CSS -->
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="#">upgrade your browser</a> to improve your experience.</p>
        <![endif]-->
        <!-- Navbar -->
        <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
            <div class="container">
                <a class="navbar-brand" href="#">Pressure</a>
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse" id="navbarSupportedContent">
                    <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                        <li class="nav-item"><a class="nav-link active" aria-current="page" href="#">Dashboard</a></li>
                        <li class="nav-item"><a class="nav-link" href="#chart">Chart</a></li>
                    </ul>
                    <div class="d-flex">
                        <button class="btn btn-outline-light btn-sm" onclick="window.location.reload()">Refresh</button>
                        <button id="btnHelp" class="btn btn-outline-info btn-sm ms-2">Help</button>
                    </div>
                </div>
            </div>
        </nav>

        <div class="container py-4">
            <h1 class="display-5 fw-bold mb-3"><img src="img/favicon.png">Pressure</h1>
            <!-- Top Connect/Disconnect -->
            <div class="d-flex align-items-center gap-2 mb-3">
                <button id="btnConnect" class="btn btn-success btn-sm">Connect</button>
                <button id="btnDisconnect" class="btn btn-outline-secondary btn-sm" disabled>Disconnect</button>
                <span id="idnInfo" class="ms-2 small text-muted"></span>
            </div>
            <!-- Panel + Chart row -->
            <div class="row mb-4">
                <!-- Left panel -->
                <div class="col-12 col-lg-4">
                    <div class="card h-100">
                        <div class="card-body">
                            <h5 class="card-title">Panel</h5>
                            <p class="text-muted mb-3">Controls and status</p>
                            <div class="vstack gap-2">
                                <div class="d-flex align-items-center justify-content-between">
                                    <span class="fw-semibold">Connection</span>
                                    <span id="connStatus" class="badge text-bg-secondary">Disconnected</span>
                                </div>
                                <div class="d-flex align-items-center justify-content-between">
                                    <span class="fw-semibold">Rate</span>
                                    <span id="rateText" class="text-muted">5 points/sec</span>
                                </div>
                                <div class="mt-2">
                                    <label for="rateSlider" class="form-label mb-1">Adjust rate (pts/sec)</label>
                                    <input id="rateSlider" type="range" class="form-range" min="1" max="10" step="1" value="5">
                                </div>
                                <div class="d-flex align-items-center justify-content-between">
                                    <span class="fw-semibold">Window</span>
                                    <span class="text-muted">50 points</span>
                                </div>
                                <div>
                                    <button id="btnSeed" class="btn btn-outline-primary btn-sm">Seed 8 points</button>
                                </div>
                                <div class="d-flex align-items-center justify-content-between mt-2">
                                    <span class="fw-semibold">Stats</span>
                                    <span class="text-muted">
                                        Min: <span id="statMin">–</span>
                                        Max: <span id="statMax">–</span>
                                        Avg: <span id="statAvg">–</span>
                                    </span>
                                </div>
                                <div class="mt-2">
                                    <button id="btnExportCsv" class="btn btn-outline-dark btn-sm">Export CSV</button>
                                </div>
                                <!-- Removed panel Connect/Disconnect; using top buttons -->
                                <div class="mt-2 d-flex gap-2">
                                    <button id="btnDemo" class="btn btn-primary btn-sm">Demo</button>
                                    <button id="btnStop" class="btn btn-outline-secondary btn-sm" disabled>Stop</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- Right chart -->
                <div class="col-12 col-lg-8">
                    <div id="chart" class="card h-100">
                        <div class="card-body p-1">
                            <h6 class="card-subtitle mb-1 text-muted">Live Pressure Chart</h6>
                            <div class="chart-container" style="position: relative; height: 420px; width: 100%; padding: 0; margin: 0;">
                                <canvas id="pressureChart" style="width: 100%; display: block; margin: 0; padding: 0;"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- Help Modal -->
        <div class="modal fade" id="helpModal" tabindex="-1" aria-labelledby="helpModalLabel" aria-hidden="true">
            <div class="modal-dialog modal-xl modal-dialog-scrollable">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="helpModalLabel">Help / README</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <div class="d-flex justify-content-between align-items-center mb-2">
                            <div class="btn-group btn-group-sm" role="group" aria-label="Help content tabs">
                                <button type="button" id="helpTabReadme" class="btn btn-primary">README</button>
                                <button type="button" id="helpTabLicense" class="btn btn-outline-primary">LICENSE</button>
                            </div>
                        </div>
                        <div id="helpContent" class="markdown-body">
                            <div class="text-muted small">Loading…</div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <small class="text-muted me-auto">Licensed under MPL-2.0 — see <a href="LICENSE" target="_blank">LICENSE</a>.</small>
                        <a href="README.md" target="_blank" class="btn btn-link">Open raw README</a>
                        <a href="LICENSE" target="_blank" class="btn btn-link">Open LICENSE</a>
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Bootstrap JS (includes Popper) -->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
        <!-- Chart.js -->
        <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
        <!-- Markdown renderer -->
        <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
        <!-- MelexisIO Web Serial (optional direct usage) -->
        <script type="module">
            import { MelexisIOcomm } from './js/MelexisIO.js';
            // Simple test harness to exercise Web Serial via the Connect button
            // Use no filters for now; chooser will list all serial-capable ports
            const io = new MelexisIOcomm({ baudRate: 921600, dataBits: 7, stopBits: 2, parity: 'odd' });
            window.__mlxio = io;
            const btn = document.getElementById('btnConnect');
            const btnD = document.getElementById('btnDisconnect');
            const idnEl = document.getElementById('idnInfo');
            if (btn && btnD) {
                btn.addEventListener('click', async () => {
                    try {
                        await io.open(false, true);
                        if (idnEl) idnEl.textContent = io.id || '(OK)';
                    } catch (e) {
                        // If user canceled or filters hid the port, retry without filters
                        if (String(e?.name) === 'NotFoundError') {
                            try {
                                // Retry once more (still no filters); show friendly message if canceled
                                const ioNoFilter = new MelexisIOcomm({ baudRate: 921600, dataBits: 7, stopBits: 2, parity: 'odd' });
                                await ioNoFilter.open(false, true);
                                window.__mlxio = ioNoFilter;
                                if (idnEl) idnEl.textContent = ioNoFilter.id || '(OK)';
                            } catch (e2) {
                                console.error('Retry without filters failed', e2);
                                // Surface a friendly message only if user canceled again
                                if (String(e2?.name) === 'NotFoundError') {
                                    alert('No serial port selected. Please pick the Melexis board in the chooser.');
                                }
                            }
                        } else {
                            console.error(e);
                        }
                    }
                });
                btnD.addEventListener('click', async () => {
                    try { await io.close(); if (idnEl) idnEl.textContent = ''; } catch {}
                });
            }
        </script>
        <script>
            (function () {
                const ctx = document.getElementById('pressureChart');
                if (!ctx) return;

                const data = {
                    labels: [],
                    datasets: [{
                        label: 'Pressure (psi)',
                        data: [],
                        borderColor: '#0d6efd',
                        backgroundColor: 'rgba(13,110,253,0.15)',
                        tension: 0.25,
                        pointRadius: 2,
                    }]
                };

                let chart = null;
                if (typeof Chart === 'function') {
                    chart = new Chart(ctx, {
                        type: 'line',
                        data,
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                x: { title: { display: true, text: 'Time' } },
                                y: { title: { display: true, text: 'psi' } }
                            },
                            layout: {
                                padding: { left: 0, right: 0, top: 0, bottom: 0 }
                            },
                            plugins: {
                                legend: { display: true },
                                tooltip: { enabled: true }
                            }
                        }
                    });
                } else {
                    console.warn('Chart.js not loaded; demo will run without rendering.');
                }

                // Demo data stream (fallback)
                let timer = null;
                let t0 = Date.now();
                const maxPoints = 50;
                let pointsPerSecond = 5; // default
                const randPsi = (prev) => {
                    const base = prev ?? 32;
                    const jitter = (Math.random() - 0.5) * 2.0; // ±1.0
                    const next = Math.max(25, Math.min(45, base + jitter));
                    return Number(next.toFixed(2));
                };

                function addPoint() {
                    const elapsed = Math.floor((Date.now() - t0) / 1000);
                    const mm = String(Math.floor(elapsed / 60)).padStart(2, '0');
                    const ss = String(elapsed % 60).padStart(2, '0');
                    const label = `${mm}:${ss}`;
                    const arr = data.datasets[0].data;
                    const nextVal = randPsi(arr.length ? arr[arr.length - 1] : undefined);
                    data.labels.push(label);
                    arr.push(nextVal);
                    if (arr.length > maxPoints) {
                        data.labels.shift();
                        arr.shift();
                    }
                    if (chart) chart.update('none');
                    updateStats();
                }

                function startDemo() {
                    if (timer) return;
                    t0 = Date.now();
                    timer = setInterval(addPoint, Math.max(50, Math.floor(1000 / pointsPerSecond)));
                    // Demo controls only; do not touch Connect/Disconnect
                    // Leave Seed enabled during demo
                }

                function stopDemo() {
                    if (!timer) return;
                    clearInterval(timer);
                    timer = null;
                    // Demo controls only; do not touch Connect/Disconnect
                    // Leave Seed enabled during demo
                }

                // USB CDC via Web Serial API
                let port = null;
                let reader = null;
                let writer = null;
                let inputStream = null;
                async function connectSerial() {
                    if (!('serial' in navigator)) {
                        alert('Web Serial API not supported in this browser. Use Chrome/Edge.');
                        return;
                    }
                    try {
                        // Always request a port fresh and open it
                        port = await navigator.serial.requestPort();
                        await new Promise(r => setTimeout(r, 150));
                        // Match MelexisIO defaults (can be adjusted if device requires 9600)
                        await port.open({ baudRate: 921600, dataBits: 7, stopBits: 2, parity: 'odd' });
                        const textDecoder = new TextDecoderStream();
                        port.readable.pipeTo(textDecoder.writable);
                        inputStream = textDecoder.readable;
                        const textEncoder = new TextEncoderStream();
                        textEncoder.readable.pipeTo(port.writable);
                        writer = textEncoder.writable.getWriter();
                        // UI state
                        const btnC = document.getElementById('btnConnect');
                        const btnD = document.getElementById('btnDisconnect');
                        if (btnC) { btnC.disabled = true; btnC.classList.add('disabled'); btnC.classList.remove('btn-success'); btnC.classList.add('btn-secondary'); }
                        if (btnD) { btnD.disabled = false; btnD.classList.remove('disabled', 'btn-outline-secondary'); btnD.classList.add('btn-success'); }
                        // Query ID and show it next to Disconnect BEFORE starting background read loop
                        try {
                            const lines = await scpi_command('*IDN?', { timeoutMs: 5000, idleMs: 500, terminatorRegex: /\s*\)>/ });
                            const el = document.getElementById('idnInfo');
                            if (el) el.textContent = Array.isArray(lines) ? lines.join(' | ') : String(lines);
                        } catch (e) {
                            console.debug('IDN query failed', e);
                        }

                        // Start background read loop
                        reader = inputStream.getReader();
                        let buffer = '';
                        (async () => {
                            try {
                                while (port && reader) {
                                    const { value, done } = await reader.read();
                                    if (done) break;
                                    if (value) {
                                        buffer += value;
                                        let idx;
                                        while ((idx = buffer.indexOf('\n')) >= 0) {
                                            const line = buffer.slice(0, idx).trim();
                                            buffer = buffer.slice(idx + 1);
                                            if (line) {
                                                const val = parseFloat(line);
                                                const elapsed = Math.floor((Date.now() - t0) / 1000);
                                                const mm = String(Math.floor(elapsed / 60)).padStart(2, '0');
                                                const ss = String(elapsed % 60).padStart(2, '0');
                                                const label = `${mm}:${ss}`;
                                                data.labels.push(label);
                                                data.datasets[0].data.push(isNaN(val) ? randPsi(data.datasets[0].data.at(-1)) : val);
                                                if (data.datasets[0].data.length > maxPoints) { data.labels.shift(); data.datasets[0].data.shift(); }
                                                if (chart) chart.update('none');
                                                updateStats();
                                            }
                                        }
                                    }
                                }
                            } catch (e) {
                                // Swallow read errors during disconnect/cancel
                            }
                        })().catch(() => {});
                    } catch (err) {
                        console.error('Serial connect error', err);
                        alert('Failed to connect to serial device.');
                    }
                }

                async function disconnectSerial() {
                    try {
                        if (reader) { await reader.cancel(); reader.releaseLock(); reader = null; }
                        if (writer) {
                            try { await writer.close(); } catch {}
                            try { writer.releaseLock(); } catch {}
                            writer = null;
                        }
                        // Small settle delay to allow underlying streams to tear down
                        await new Promise(r => setTimeout(r, 200));
                        if (port) { try { await port.close(); } catch {} port = null; }
                        inputStream = null;
                    } catch (err) {
                        console.warn('Serial disconnect issue', err);
                    } finally {
                        const btnC = document.getElementById('btnConnect');
                        const btnD = document.getElementById('btnDisconnect');
                        const idn = document.getElementById('idnInfo');
                        if (btnC) { btnC.disabled = false; btnC.classList.remove('disabled', 'btn-secondary'); btnC.classList.add('btn-success'); }
                        if (btnD) { btnD.disabled = true; btnD.classList.add('disabled'); btnD.classList.remove('btn-success'); btnD.classList.add('btn-outline-secondary'); }
                        if (idn) { idn.textContent = ''; }
                    }
                }

                // Send SCPI command and read a multi-line response.
                // Returns an array of lines. Uses idle timeout to detect end.
                async function scpi_command(command, { timeoutMs = 3000, idleMs = 200, terminatorRegex = /\)>/ } = {}) {
                    if (!port || !writer || !inputStream) {
                        throw new Error('Serial port not connected');
                    }
                    // Pause background reader if active to avoid stream contention
                    let hadBackgroundReader = !!reader;
                    if (reader) {
                        try { await reader.cancel(); } catch {}
                        try { reader.releaseLock(); } catch {}
                        reader = null;
                    }

                    // Write command + newline
                    await writer.write(`${command}\n`);

                    // Dedicated reader for response
                    const tempReader = inputStream.getReader();
                    let buffer = '';
                    const lines = [];
                    const start = Date.now();
                    let lastDataTs = Date.now();
                    try {
                        while (Date.now() - start < timeoutMs) {
                            const race = await Promise.race([
                                tempReader.read(),
                                new Promise(resolve => setTimeout(() => resolve({ value: null, done: false, idle: true }), 25))
                            ]);
                            const { value, done } = race;
                            if (done) break;
                            if (value) {
                                buffer += value;
                                lastDataTs = Date.now();
                                let idx;
                                while ((idx = buffer.indexOf('\n')) >= 0) {
                                    const line = buffer.slice(0, idx).trimEnd();
                                    buffer = buffer.slice(idx + 1);
                                    const trimmed = line.trim();
                                    if (trimmed.length) {
                                        lines.push(trimmed);
                                        if (terminatorRegex && terminatorRegex.test(trimmed)) {
                                            return lines;
                                        }
                                    }
                                }
                            }
                            // End if idle for idleMs
                            if (Date.now() - lastDataTs >= idleMs && lines.length) {
                                return lines;
                            }
                        }
                        // If buffer has remaining content, flush last line
                        const final = buffer.trim();
                        if (final) lines.push(final);
                        if (lines.length) return lines;
                        throw new Error('Timeout waiting for response');
                    } finally {
                        try { tempReader.releaseLock(); } catch {}
                        // Resume background reader if it was active, without chart/demo updates
                        if (hadBackgroundReader && port) {
                            try {
                                reader = inputStream.getReader();
                                (async () => {
                                    try {
                                        let bufferBg = '';
                                        while (port && reader) {
                                            const { value, done } = await reader.read();
                                            if (done) break;
                                            if (value) {
                                                bufferBg += value;
                                                let idx;
                                                // Consume lines silently to keep stream flowing
                                                while ((idx = bufferBg.indexOf('\n')) >= 0) {
                                                    bufferBg = bufferBg.slice(idx + 1);
                                                }
                                            }
                                        }
                                    } catch (e) {
                                        // Ignore during disconnect/cancel
                                    }
                                })().catch(() => {});
                            } catch {}
                        }
                    }
                }

                // Hook up buttons (top bar)
                document.getElementById('btnConnect')?.addEventListener('click', connectSerial);
                document.getElementById('btnDisconnect')?.addEventListener('click', disconnectSerial);
                document.getElementById('btnDemo')?.addEventListener('click', () => {
                    startDemo();
                    const btnDemo = document.getElementById('btnDemo');
                    const btnStop = document.getElementById('btnStop');
                    if (btnDemo) { btnDemo.disabled = true; btnDemo.classList.add('disabled'); }
                    if (btnStop) { btnStop.disabled = false; btnStop.classList.remove('disabled'); btnStop.classList.add('btn-danger'); btnStop.classList.remove('btn-outline-secondary'); }
                });
                document.getElementById('btnStop')?.addEventListener('click', () => {
                    stopDemo();
                    const btnDemo = document.getElementById('btnDemo');
                    const btnStop = document.getElementById('btnStop');
                    if (btnDemo) { btnDemo.disabled = false; btnDemo.classList.remove('disabled'); }
                    if (btnStop) { btnStop.disabled = true; btnStop.classList.add('disabled'); btnStop.classList.remove('btn-danger'); btnStop.classList.add('btn-outline-secondary'); }
                });
                // Keep demo buttons accessible via navbar, or call startDemo() manually if needed
                document.getElementById('btnSeed')?.addEventListener('click', () => {
                    for (let i = 0; i < 8; i++) addPoint();
                });
                // Rate slider control
                const rateSlider = document.getElementById('rateSlider');
                const rateText = document.getElementById('rateText');
                rateSlider?.addEventListener('input', (e) => {
                    const val = Number(rateSlider.value);
                    pointsPerSecond = Math.min(10, Math.max(1, val));
                    if (rateText) rateText.textContent = `${pointsPerSecond} points/sec`;
                    // If running, restart timer with new rate
                    if (timer) {
                        clearInterval(timer);
                        timer = setInterval(addPoint, Math.max(50, Math.floor(1000 / pointsPerSecond)));
                    }
                });

                // Seed with a few points
                for (let i = 0; i < 8; i++) addPoint();

                // Expose for future updates
                window.pressureChart = chart;
                window.startDemoPressure = startDemo;
                window.stopDemoPressure = stopDemo;

                // Stats calculation and CSV export
                function calculateStats() {
                    const arr = data.datasets[0].data;
                    if (!arr.length) return { min: null, max: null, avg: null };
                    let min = Infinity, max = -Infinity, sum = 0;
                    for (let i = 0; i < arr.length; i++) {
                        const v = Number(arr[i]);
                        if (Number.isFinite(v)) {
                            if (v < min) min = v;
                            if (v > max) max = v;
                            sum += v;
                        }
                    }
                    const avg = sum / arr.length;
                    return { min, max, avg };
                }

                function updateStats() {
                    const { min, max, avg } = calculateStats();
                    const elMin = document.getElementById('statMin');
                    const elMax = document.getElementById('statMax');
                    const elAvg = document.getElementById('statAvg');
                    if (elMin) elMin.textContent = (min == null ? '–' : min.toFixed(2));
                    if (elMax) elMax.textContent = (max == null ? '–' : max.toFixed(2));
                    if (elAvg) elAvg.textContent = (avg == null ? '–' : avg.toFixed(2));
                }

                function exportCsv() {
                    const rows = [['time','pressure']];
                    const labels = data.labels;
                    const values = data.datasets[0].data;
                    for (let i = 0; i < values.length; i++) {
                        rows.push([labels[i] ?? '', String(values[i])]);
                    }
                    const csvContent = rows.map(r => r.map(field => {
                        const s = String(field);
                        return /[",\n]/.test(s) ? '"' + s.replace(/"/g, '""') + '"' : s;
                    }).join(',')).join('\n');
                    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    const ts = new Date().toISOString().replace(/[:.]/g,'-');
                    a.download = `pressure-data-${ts}.csv`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }

                document.getElementById('btnExportCsv')?.addEventListener('click', exportCsv);
                // initial stats render
                updateStats();

                // Update connection badge
                const badge = document.getElementById('connStatus');
                const updateBadge = (connected) => {
                    if (!badge) return;
                    if (connected) {
                        badge.className = 'badge text-bg-success';
                        badge.textContent = 'Connected';
                    } else {
                        badge.className = 'badge text-bg-secondary';
                        badge.textContent = 'Disconnected';
                    }
                };
                document.getElementById('btnConnect')?.addEventListener('click', () => updateBadge(true));
                document.getElementById('btnDisconnect')?.addEventListener('click', () => updateBadge(false));
                // Initialize button states based on timer
                (function initButtons(){
                    const btnC = document.getElementById('btnConnect');
                    const btnD = document.getElementById('btnDisconnect');
                    const btnSeed = document.getElementById('btnSeed');
                    if (btnC) btnC.disabled = !!timer;
                    if (btnC) {
                        btnC.classList.remove('btn-success', 'btn-secondary');
                        btnC.classList.add(timer ? 'btn-secondary' : 'btn-success');
                    }
                    if (btnD) {
                        btnD.disabled = !timer;
                        // Style based on connection state
                        btnD.classList.remove('btn-success', 'btn-outline-secondary');
                        btnD.classList.add(timer ? 'btn-success' : 'btn-outline-secondary');
                    }
                    if (btnSeed) {
                        btnSeed.disabled = !!timer;
                        btnSeed.classList.remove('btn-outline-primary', 'btn-outline-secondary');
                        btnSeed.classList.add(timer ? 'btn-outline-secondary' : 'btn-outline-primary');
                    }
                })();
                updateBadge(false);

                // Help modal logic
                const helpBtn = document.getElementById('btnHelp');
                const helpModalEl = document.getElementById('helpModal');
                const helpContent = document.getElementById('helpContent');
                const tabReadmeEl = document.getElementById('helpTabReadme');
                const tabLicenseEl = document.getElementById('helpTabLicense');
                let readmeLoaded = false;
                let licenseLoaded = false;
                let readmeHtml = null;
                let licenseHtml = null;
                let helpModalInstance = null;

                function setActiveTab(which) {
                    if (tabReadmeEl && tabLicenseEl) {
                        if (which === 'readme') {
                            tabReadmeEl.classList.remove('btn-outline-primary');
                            tabReadmeEl.classList.add('btn-primary');
                            tabLicenseEl.classList.remove('btn-primary');
                            tabLicenseEl.classList.add('btn-outline-primary');
                        } else {
                            tabLicenseEl.classList.remove('btn-outline-primary');
                            tabLicenseEl.classList.add('btn-primary');
                            tabReadmeEl.classList.remove('btn-primary');
                            tabReadmeEl.classList.add('btn-outline-primary');
                        }
                    }
                }

                function escapeHtml(s) {
                    return s.replace(/[&<>"']/g, (ch) => ({
                        '&': '&amp;',
                        '<': '&lt;',
                        '>': '&gt;',
                        '"': '&quot;',
                        "'": '&#39;'
                    })[ch] || ch);
                }

                async function loadReadme() {
                    setActiveTab('readme');
                    if (!readmeLoaded) {
                        helpContent.innerHTML = '<div class="text-muted small">Loading…</div>';
                        try {
                            const resp = await fetch('README.md', { cache: 'no-cache' });
                            if (!resp.ok) throw new Error('HTTP ' + resp.status);
                            const md = await resp.text();
                            if (window.marked && typeof window.marked.parse === 'function') {
                                readmeHtml = window.marked.parse(md);
                            } else if (window.marked) {
                                readmeHtml = window.marked(md);
                            } else {
                                readmeHtml = md.replace(/</g,'&lt;').replace(/>/g,'&gt;');
                            }
                            readmeLoaded = true;
                        } catch (e) {
                            readmeHtml = '<div class="text-danger">Failed to load README. Serve the app via http(s) (e.g., http://localhost) and try again.</div>';
                        }
                    }
                    helpContent.innerHTML = readmeHtml || '';
                }

                async function loadLicense() {
                    setActiveTab('license');
                    if (!licenseLoaded) {
                        helpContent.innerHTML = '<div class="text-muted small">Loading…</div>';
                        try {
                            const resp = await fetch('LICENSE', { cache: 'no-cache' });
                            if (!resp.ok) throw new Error('HTTP ' + resp.status);
                            const txt = await resp.text();
                            licenseHtml = '<pre class="bg-light p-3 small" style="white-space: pre-wrap;">' + escapeHtml(txt) + '</pre>';
                            licenseLoaded = true;
                        } catch (e) {
                            licenseHtml = '<div class="text-danger">Failed to load LICENSE. Serve the app via http(s) (e.g., http://localhost) and try again.</div>';
                        }
                    }
                    helpContent.innerHTML = licenseHtml || '';
                }

                if (helpBtn && helpModalEl && helpContent) {
                    helpBtn.addEventListener('click', async () => {
                        try {
                            if (!helpModalInstance) {
                                helpModalInstance = new bootstrap.Modal(helpModalEl);
                            }
                            await loadReadme();
                            helpModalInstance.show();
                        } catch (e) {
                            console.error('Help modal error', e);
                            alert('Unable to open Help panel.');
                        }
                    });
                    tabReadmeEl?.addEventListener('click', () => { loadReadme(); });
                    tabLicenseEl?.addEventListener('click', () => { loadLicense(); });
                }
            })();
            // Suppress unhandled promise rejections from stream teardown during disconnect
            window.addEventListener('unhandledrejection', (event) => {
                // Prevent default error logging
                try { event.preventDefault(); } catch {}
                // Optional debug output
                try { console.debug('Suppressed unhandled promise', event.reason); } catch {}
            });
        </script>
    </body>
</html>